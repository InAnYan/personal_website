---
title: Automatic solving of physics word problems
authors: Ruslan Popov, Nadiia Karpenko
university: Oles Honchar Dnipro National University (Ukraine)
abstract: |
    We present a system that solves simple physics
    word problems (PWPs) stated in the English language. PWP is an
    interesting subfield of word problems that is not studied as deeply as
    math word problems (MWPs). We described the process of analyzing English
    text, the representation of problems, and algorithms for finding the
    solution. We have researched the types of PWPs and described their
    problem-solving strategies. We have noted the peculiarities that PWPs
    introduce in comparison to MWPs. We discussed the capabilities and
    limitations of our implementation and proposed future research areas.
keywords: physics word problems, automatic problem solving, artificial intelligence, natural language processing, natural language understanding
year: 2024
tags: paper
permalink: "papers/paper1.html"
layout: paper.njk
---

<h1 id="introduction" class="section">INTRODUCTION</h1>
<p>With the publication of Large Language Models (LLMs), students are tempted to solve their school problems by using
    AIs such as ChatGPT, Bard, etc. However, recent studies show that LLMs cannot solve physics problems well
    <span class="citation" data-cites="frust_soc">(Gregorcic and Pendrill 2023)</span>. Indeed, LLMs are neural models that
        try to predict the next word of the answer probabilistically. Thus, neither students nor engineers can trust the output
        of the model.</p>
<p>Solving word problems is a classic and challenging field of AI programming. The automatic solving of such problems
    involves natural language processing, a well-formed problem representation, and a good problem-solving strategy.</p>
<p>In this paper, we want to study the automatic solving of physics word
                    problems.</p>
<p>There are several reasons for the relevance of our paper:</p>
<ul>
    <li>
        <p>The field of word problem solving is very diverse, and its research has not developed as quickly as the research, for
            example, of neural networks.</p>
    </li>
    <li>
        <p>A significant research gap exists in understanding how to solve word problems within specific scientific fields (such
            as physics, chemistry, etc.) , whereas MWP solving has been a well-established area of study.</p>
    </li>
    <li>
        <p>Physics word problems bring new challenges in automatic solving that require specific techniques to overcome
            them.</p>
    </li>
    <li>
        <p>While many arithmetic word problem data sets exist, there is no widely used collection of physics
            problems.</p>
    </li>
</ul>
<p>We want to revive the classic AI approach where programs solve human problems in a correct and deterministic way,
    where programs utilize the field knowledge, rules, and definitions to give a strict and accurate answer.</p>
<h1 id="literature-analysis" class="section">LITERATURE ANALYSIS</h1>
<h2 id="student-pioneer-ai-program" class="subsection">STUDENT: Pioneer AI program</h2>
<p>The D. Bobrow’s STUDENT program is one of the first AI programs to understand natural language, showing promising
    results
    <span class="citation" data-cites="student">(Bobrow 1964)</span>. The program solves algebraic word problems stated in
        English. An example of the problem that STUDENT can handle:</p>
<p>“<em>If the number of customers Tom gets is twice the square of 20% of the number of advertisements he runs, and the
    number of advertisements is 45, then what is the number of customers Tom gets?</em>””</p>
<p>The STUDENT approach is straightforward: the problem is represented as a set of simultaneous equations; the solution
    of the problem is the solution for that set. The program used pattern matching and kernel sentence theory to transform
    English text into a set of equations. For the example above, STUDENT would generate this system:</p>
<p>
    <span class="math display">$$\begin{cases} (CUSTOMERS) = 2 * (0.2 + (ADVERTISMENTS)) ^ 2 \\ (ADVERTISMENTS) = 45 \\ ? =
        (CUSTOMERS) \end{cases}$$</span>
</p>
<p>Words in the problem text resemble mathematical operations and variables, so the STUDENT can translate the English
    text into mathematical expressions using pattern matching. The question mark is a special symbol used to denote the
    unknown value. The variables in the equation are subparts of the problem text.</p>
<p>When the set of equations is unsolvable, the STUDENT will try to solve it again with several techniques applied. For
    example, STUDENT may change variable names to be equal if they have some words in common (e.g., “<em>SPEED</em>” and “<em>SPEED OF THE CAR</em>”). Or, the
                    STUDENT may add new equations from its internal knowledge of the
                    world.</p>
<p>The STUDENT program is nearly 60 years old. The field of AI programming has improved since that time. Peter Norvig
    presented an analysis and elegant implementation of STUDENT written in Common Lisp in functional programming style
    <span class="citation" data-cites="paip">(Norvig 1991)</span>.</p>
<h2 id="math-word-problem-solvers" class="subsection">Math word problem solvers</h2>
<p>We want to continue the literature overview by analyzing math word problem solvers. We want to inherit the researched
    knowledge of natural language processing and problem representation that is studied in this field of word
    problem-solving.</p>
<p>Here is the list and analysis of different problem representations for MWPs structured by Mandal et
    al.
    <span class="citation" data-cites="mwp_repr">(Mandal and Naskar 2019)</span>:</p>
<ul>
    <li>
        <p>Equation template representation. An equation template is a predetermined equation that is formed with arithmetic
            operations and with two types of unknowns (called slots): unknown variables and numbers. Using statistical approaches,
            the words in the problem are aligned into these unknown slots.</p>
    </li>
    <li>
        <p>Equation tree representation. The whole problem is converted into an equation tree using statistical methods.
            Usually, recognizers generate several trees, so another approach is applied to choose the best.</p>
    </li>
    <li>
        <p>Entity and state transition-based representation. In this approach, the problem consists of states and state
            transitions. A state contains all the information of the known objects (their owners, count, and type). State transition
            would change the count of belonging objects, which can result in an equation.</p>
    </li>
    <li>
        <p>Tag-based representation. In this method, the text is processed in several stages. First, it is tokenized and parsed.
            Then, the type of problem is recognized. After that, several logic forms representing grammatical relations and
            quantities are generated. An answer is generated using special techniques.</p>
    </li>
</ul>
<p>The natural language processing of MWPs has many methods, including rule-based techniques and statistical and neural
    models. Often, solvers parse the English text into dependency trees. Common features extracted from the text are part of
    speech tag, the lemma of a word, quantities, units of quantities, comparative adverbs, dependencies between verbs and
    quantities, etc.
    <span class="citation" data-cites="mwp_nlp">(Zhang et al. 2020)</span>.</p>
<h2 id="physics-word-problem-solvers" class="subsection">Physics word problem solvers</h2>
<p>There is not so much research and categorization on PWP solvers. Most programs date back to 1970-1980 and use their
    own knowledge representation and custom natural language processing methods.</p>
<p>One of the first programs that could handle PWP is the NEWTON program
                    by Kleer
    <span class="citation" data-cites="newton">(Kleer 1977)</span>. It is made to solve mechanical problems. NEWTON would
        analyze the programs text and convert it to several data structures. The first data structure depicts objects, and the
        second is a tree-like data structure (called “envisioning tree”) that holds all possible states of the objects. The
        trees root is the starting position, and the next children are the next events. When the tree divides, it means that
        there are several possibilities where an object could move. Quantitative knowledge is presented in a data structure
        called FRAME. It stores all the known parameters of the object and the equations that connect those parameters.</p>
<p>Gordon S. Novak Jr. has studied the topic of physics problems very thoroughly. One of the programs he developed is
    ISAAC
    <span class="citation" data-cites="isaac">(Novak 1976)</span>. This problem understands and solves physics problems that
        involve rigid bodies in static equilibrium. The program can also draw a diagram of the problem.</p>
<p>ISAAC problem analysis consists of lots of stages, and they have several branches. Firstly, an augmented transition
    network transforms the English text into structured parsed sentences. Then, the semantic analysis is performed. It is
    used to determine the meaning of verbs and prepositions. After several stages, a canonical object model is formed. In
    this data structure, objects in the problem are represented as physics objects (point, pivot, lever, etc.). The
    canonical object model is then passed to the EUCLID program, which analyzes the orientation of objects and assigns
    coordinates to them. After that, the geometric model is formed. Problem-solving involves creating a set of equations
    that represent physical laws between objects.</p>
<p>The ISAAC program is big and complex. It is hard to analyze it because of its age and programming style. As the
    author states, 44 pages of Lisp code is written only for parsing the English text, while problem-solving is one of the
    simplest parts of the program. We were unable to find the source code of the ISAAC program.</p>
<p>Bundy et al. created the MECHO program, which addresses mechanical
                    PWPs and is implemented in Prolog
    <span class="citation" data-cites="mecho">(Bundy et al. 1979)</span>. The program processes the word problem in several
        stages. First, it parses the text, extracting information. Then, MECHO derives assertions related to objects, given
        parameters, and unknown values from the parsed data. These assertions are then transformed into a particular data
        structure called schema, where inference rules, resembling logical representations of physics laws in Prolog, are
        applied. MECHO can provide either symbolic or numerical solutions.</p>
<p>Mukherjee et al. have an extensive overview of rule-based word problem solvers and a dedicated section for PWPs.
    Other programs for solving PWPs include BEATRIX, ALBERT, and FREEBODY
    <span class="citation" data-cites="other_pwp">(Mukherjee and Garain 2008)</span>. All those programs address only
        specific types of physics problems. As the reader may notice, all the names of the programs resemble human names and are
        written in upper-case. Possibly, this tradition came after the STUDENT program.</p>
<p>We have found a modern paper on PWP solving. Leszczynski et al. address the problems of a free-falling object under
    constant acceleration of gravity
    <span class="citation" data-cites="modern_pwp">(Leszczynski and Moreira 2017)</span>. The problem is analyzed using
        several recurrent neural networks (RNN), then the dynamical system is formed, and the solution is provided at the end.
        The first RNN is a word labeler used to extract the given values and the problem question. The second RNN is a
        classifier that determines the type of question. While this work seems modern and interesting, the accepted problem set
        is limited and generated artificially using context-free grammar.</p>
<h2 id="conclusions-of-literature-analysis" class="subsection">Conclusions of literature analysis</h2>
<p>We have investigated the design of several word problem solvers. Unfortunately, we concluded that a few techniques
    apply to make a generic PWP solver. Or at least the known methods cannot solve problems from Ukrainian physics
    textbooks.</p>
<p>There are some issues in using STUDENT to solve physics problems.
                    Consider the problem: “<em>If the
    distance between Dnipro and Kyiv is 477 kilometers and the time the automobile has traveled is 6 hours, then what is the
    speed of the automobile?</em>”. The STUDENT would generate
                    this set of equations:</p>
<p>
    <span class="math display">$$\begin{cases} (DISTANCE) = 477\ kilometers \\ (TIME) = 6\ hours \\ ? = (SPEED)
        \end{cases}$$</span>
</p>
<p>As the reader may notice, the STUDENT has generated a system consisting of given values and unknowns. This set would
    resemble the column “Given”, which is usually written by students. But the physics problem cannot be represented like
    this set of equations for two reasons:</p>
<ol>
    <li>
        <p>This set is unsolvable. A set of equations requires that all the information needed to find the unknowns is present
            in the set. But our example has no connection between speed, time, and distance.</p>
    </li>
    <li>
        <p>There is a theoretical issue. In math, variables represent unknown values and act like bound variables in lambda
            calculus: their names can be changed freely unless they interfere with another name. But in the physics field, the name
            of variables has a special meaning. It is a given value that marks some parameter of an object.</p>
    </li>
</ol>
<p>In this example, STUDENT would add needed equations from its internal knowledge using the search on the first word of
    a variable (it may find the relation “<em>the distance is equal to time multiplied by
                    speed</em>
    ”). While this approach may work for simple problems like the one above, it is not the best solution because it is too
    chaotic and brute-force-like.</p>
<p>The approaches presented in subsection 2.2 are not sufficient to represent physics problems. They are constructed
    around math expressions, though in PWP, usually there are no explicitly stated expressions (only given values are
    specified).</p>
<p>Most papers for word problem-solving are outdated. They use unstandardized programming languages with undefined
    styles of programming. The analysis of the capabilities and limitations of previous works is not enough.</p>
<h1 id="object-subject-and-methods-of-research" class="section">OBJECT, SUBJECT, AND METHODS OF RESEARCH</h1>
<h2 id="object-and-subject" class="subsection">Object and subject</h2>
<p>The object of our research is automatic word problem-solving. The subject of our research is the automatic solving of
    physics word problems.</p>
<h2 id="method-of-the-research" class="subsection">Method of the research</h2>
<p>To study the subject, we developed a program that can solve basic PWPs stated in the English language, which do not
    involve any dynamic change or complex representation. Also, we do not support solving problems where a graphical model
    is needed (forces, impulses, energy, etc.).</p>
<p>The whole program was written in Python language. We have separated our program into two projects: one is a user
    interface, and the other is the core library. The technology stack of the user interface consists of Django (web
    framework), MathJax (LATEX output), and Bootstrap (graphical design). The library uses spaCy (natural language
    processing) and SymPy (symbolic math) libraries. We used PythonAnywhere to host our program (<a href="https://inanyan.pythonanywhere.com/" class="uri">
        https://inanyan.pythonanywhere.com/</a>).</p>
<p>By definitions provided in AI:MA
    <span class="citation" data-cites="aima">(Russell and Norvig 2009)</span>, we consider our program to be inside the
        “Thinking Rationally” field because we are trying to find the computational model behind PWP solving and provide the
        user with a correct problem solution.</p>
<p>The whole NLP pipeline, algorithms, and data structures that are used by our program can be depicted through this
    diagram:</p>
<figure>
    <img src="/media/image2.png" style="width:75.0%"/>
    <figcaption>Algorithms and data structures of our program.</figcaption>
</figure>
<p>In fig. 1 nodes represent algorithms, right after the node comes a brief comment on the chosen approach, and the
    labels of the arrows are data structures. In section IV of the paper, we will describe all the steps of the program, but
    before that, we will discuss the found types of physics problems to understand what features we need to extract from
    English text.</p>
<h2 id="testing-data" class="subsection">Testing data</h2>
<p>To test our program, we created a small dataset with physics problems collected from various sources such
        as
    <span class="citation" data-cites="ukr_ph_1">(Гельфгат 2009)</span>,
    <span class="citation" data-cites="ukr_ph_2">(Ненашев 2011)</span>, and the Internet. We
                                        translated the Ukrainian variants to English.</p>
<h1 id="description-of-the-program" class="section">DESCRIPTION OF THE PROGRAM</h1>
<h2 id="problem-types" class="subsection">Problem types</h2>
<p>The first thing we did before starting to make this program was to study available PWP. We noticed that PWPs fall
    into five categories:</p>
<ul>
    <li>
        <p>Theoretical problem: “<em>Why do we not observe the daily rotation of the earth in everyday
            life?</em>”.</p>
    </li>
    <li>
        <p>Value conversion problem: “<em>The car is traveling at a speed of 108 kilometers per hour. Represent this speed in
                        meters per second</em>”.</p>
    </li>
    <li>
        <p>Value comparison problem: “<em>Which speed is bigger: 10 meters
                                                            per second or 10 kilometers per hour?</em>”.</p>
    </li>
    <li>
        <p>Unknowns finding problem: “<em>The car drove for 40 minutes at a speed of 144 kilometers per hour. How far did the
                        car travel?</em>”.</p>
    </li>
    <li>
        <p>Calculation of the change of a value depending on other value changes:
            “<em>How many times will the speed of wave
            propagation increase if the wavelength increases by three times and the period of oscillation remains unchanged?</em>”.</p>
    </li>
</ul>
<p>We decided not to solve the theoretical problems because they require an extensive ontology of physics definitions
    and laws, while we were more focused on computational problems.</p>
<h2 id="named-entity-recognition" class="subsection">Named Entity Recognition</h2>
<p>We chose the named entity recognition (NER) method for the feature extraction task. In this method, subparts of text,
    called entities, are marked with a particular string that represents the type of an entity.</p>
<p>We have collected the information about which entities our program
                    should recognize:</p>
<ul>
    <li>
        <p>Given values: “<em>the distance is 10 kilometers</em>”, “<em>the
                                                            mass is 50 grams</em>”, etc.</p>
    </li>
    <li>
        <p>Unknown values: “<em>What is the speed…</em>”, “<em>Determine the
                                                            density of…</em>”, etc.</p>
    </li>
    <li>
        <p>Units: “<em>meters per second</em>”, “<em>kilogram</em>”,
                                                            “<em>Newton</em>”, etc.</p>
    </li>
    <li>
        <p>Value changes: “<em>time is increased by a factor of 2</em>”,
                                                            etc.</p>
    </li>
</ul>
<p>For NER, we chose a rule-based method – pattern matching. We will present the patterns we used for NER with our
    modified BNF notation because there is no standardized way to do this. In this notation, no recursion is allowed.
    Terminals are written as is and may resemble either the lowercase form of a token or its lemma. Non-terminals are
    written inside ‘&lt;’ and ‘&gt;’. Entities are written as non-terminals whose names are written in uppercase form; the
    other non-terminals are fragments used only for easier construction of the grammar. The special rule &lt;like_num&gt;
    denotes one token resembling a number. An ellipsis indicates a part of the rule that was shortened in the paper.</p>
<p>Here is the list of all the rules:</p>
<div class="grammar">
    <p>&lt;unit_name&gt; ::= meter | hour | kilogram | candela | lux |
                                        ...</p>
    <p>&lt;modifier&gt; ::= cubic | square</p>
    <p>&lt;single_unit&gt; ::= [&lt;modifier&gt;] &lt;unit_name&gt;</p>
    <p>&lt;compound_unit&gt; ::= &lt;single_unit&gt; per
                                        &lt;single_unit&gt;</p>
    <p>&lt;UNIT&gt; ::= &lt;single_unit&gt; | &lt;compound_unit&gt;</p>
    <p>&lt;QUANTITY&gt; ::= &lt;like_num&gt; &lt;UNIT&gt;</p>
    <p>&lt;COMPARISON_WORD&gt; ::= greater | faster | bigger | larger |
                                        slower | less | ...</p>
    <p>&lt;single_term&gt; ::= density | volume | speed | length | moment |
                                        force | ...</p>
    <p>&lt;compound_term&gt; ::= ampere force | wave propagation | ...</p>
    <p>&lt;simple_term&gt; ::= &lt;single_term&gt; |
                                        &lt;compound_term&gt;</p>
    <p>&lt;of_term&gt; ::= &lt;simple_term&gt; of [&lt;determiner&gt;]
                                        &lt;simple_term&gt;</p>
    <p>&lt;TERM&gt; ::= &lt;simple_term&gt; | &lt;of_term&gt;</p>
    <p>&lt;UNKNOWN_QUESTION&gt; ::= what | determine | calculate</p>
    <p>&lt;special_unknown_word&gt; ::= far | fast | often</p>
    <p>&lt;UNKNOWN_HOW_QUESTION&gt; ::= how &lt;special_unknown_word&gt;</p>
    <p>&lt;neg_change_word&gt; ::= decrease | reduce</p>
    <p>&lt;pos_change_word&gt; ::= increase</p>
    <p>&lt;determiner&gt; ::= a | an | the</p>
    <p>&lt;change_pattern&gt; ::= by [&lt;determiner&gt; factor of]
                                        &lt;like_num&gt;</p>
    <p>&lt;NEG_CHANGE&gt; ::= &lt;neg_change_word&gt;
                                        &lt;change_pattern&gt;</p>
    <p>&lt;POS_CHANGE&gt; ::= &lt;pos_change_word&gt;
                                        &lt;change_pattern&gt;</p>
    <p>&lt;CHANGE_VERB&gt; ::= &lt;pos_change_word&gt; |
                                        &lt;neg_change_word&gt; | change</p>
</div>
<p>We provide here an example of NER to understand this process
                    better:</p>
<figure>
    <img src="/media/image3.png"/>
    <figcaption>Example of named entity recognition for an unknown finding
                                        problem.</figcaption>
</figure>
<figure>
    <img src="/media/image4.png"/>
    <figcaption>Example of named entity recognition for a value change
                                        problem.</figcaption>
</figure>
<h2 id="problem-type-recognition" class="subsection">Problem type recognition</h2>
<p>The program determines the type of problem by looking at the presence of entities. The algorithm can be described in
    English like this:</p>
<ol>
    <li>
        <p>If there is a CHANGE_VERB entity, then it is a value change
                                                            problem.</p>
    </li>
    <li>
        <p>If there is a UNIT entity, then it is a conversion
                                                            problem.</p>
    </li>
    <li>
        <p>If there is a COMPARSON_WORD entity, then it is a comparison
                                                            problem.</p>
    </li>
    <li>
        <p>If there is an UNKNOWN_QUESTION or UNKNOWN_HOW_QUESTION entity, then it is an unknown finding
            problem.</p>
    </li>
    <li>
        <p>Otherwise, the program cannot recognize the type of
                                                            problem.</p>
    </li>
</ol>
<h2 id="entities-to-problem-representation-conversion" class="subsection">Entities to problem representation conversion</h2>
<p>The algorithm for converting a list of entities to problem representation according to the recognized problem type
    can be described like this:</p>
<ol>
    <li>
        <p>For value conversion problem, extract a quantity and a
                                                            unit.</p>
    </li>
    <li>
        <p>For value comparison problems, extract two quantities.</p>
    </li>
    <li>
        <p>For unknowns finding problem, extract given and unknown
                                                            values.</p>
    </li>
    <li>
        <p>For value change problems, extract the value changes and the value in
            question.</p>
    </li>
</ol>
<p>To convert a quantity into the internal math representation, the program converts the number (the first token) and
    the unit (the rest).</p>
<p>We have found that units in SymPy are written as regular English words, allowing us to use Python’s insecure “eval”
    function. The program will convert the unit entity into a valid Python expression and call the “eval” function. We
    replace the word “<em>per</em>” with the division
                    symbol. To parse the modifiers “<em>square</em>” and “<em>cube</em>”, we
                    replace those words with “**2” and “**3”, respectively, after the single
                    unit.</p>
<p>We have found two ways in which given values are encoded in the list of entities. It is either a pair of TERM and
    QUANTITY or a single QUANTITY.</p>
<p>To convert the pair of TERM and QUANTITY into a given value, the program needs to convert the term into a symbol (the
    QUANTITY will be the value of a given variable). The program uses a hard-coded map data structure, the key to which is a
    string, and the value is a symbol (e.g., “<em>force</em>” is
    <span class="math inline">
        <em>F</em>
    </span>,
                    “<em>mass</em>” is
    <span class="math inline">
        <em>m</em>
    </span>,
                    etc.).</p>
<p>A special technique for determining the symbol should be applied to convert a single QUANTITY into a given value. We
    have found that looking at the unit of a quantity can infer the variable. If the unit is one English word, the program
    uses a hard-coded map data structure (e.g., “<em>meters</em>” is
    <span class="math inline">
        <em>S</em>
    </span>,
                    “<em>seconds</em>” is
    <span class="math inline">
        <em>t</em>
    </span>,
                    etc.).</p>
<p>The conversion of compound units and units with modifiers is tricky. However, we noticed that compound units resemble
    a physical formula (e.g., “<em>meters per second</em>” corresponds to
    <span class="math inline">$v = \frac{S}{t}$</span>, etc.). So, the program will first convert all one-word units in the
        compound unit to the symbols. Then, if the expression is not a single unit, the program will search the list of formulas
        for a formula, the right-hand side of which is identical to the result expression.</p>
<p>The whole process described above ended up being so powerful that the program will use it while presenting the output
    of value comparison and conversion problems.</p>
<p>Unknown values are encoded either as a pair of UNKNOWN_QUESTION and TERM or as a single UNKNOWN_HOW_QUESTION. For the
    first variant, it is sufficient to convert the TERM into a variable, and for the second variant, we use a hard-coded map
    data structure (e.g., “<em>how
                    far</em>” is
    <span class="math inline">
        <em>S</em>
    </span>, “<em>how
                                        fast</em>” is
    <span class="math inline">
        <em>υ</em>
    </span>, etc.).</p>
<p>Value changes are encoded as a pair of TERM and POS_CHANGE or TERM and NEG_CHANGE. To convert these pairs into a
    variable change, the program should infer the variable by the TERM entity and determine the factor of the variable
    change. According to our NER rules, the factor number comes at the end of the POS_CHANGE and NEG_CHANGE. So, it is
    enough to parse the last token in the span. If the entity is NEG_CHANGE, the parser should also take the numbers
    reciprocal.</p>
<p>The value under change is encoded as a pair of TERM and CHANGE_WORD. It is enough to infer the variable from the TERM
    entity.</p>
<h2 id="problem-solving" class="subsection">Problem-solving</h2>
<p>Solving value conversion and comparison problems is trivial, and it is a primitive operation in the SymPy library, so
    we will not describe these processes. However, we note that for value comparison problems, the program will convert the
    second value to the unit of the first value.</p>
<p>We define the solution to unknowns finding problems as a list of formulas. This list resembles a plan of actions that
    the computer should perform. The calculation of the final answer is delegated to the output part of our program.</p>
<p>The first attempt to solve an unknown finding problem would be to use a search algorithm for each unknown variable to
    find a formula left-hand side of which is equal to the unknown. But this approach is wrong for several reasons:</p>
<ul>
    <li>
        <p>The program could find several applicable formulas for one
                                                            unknown.</p>
    </li>
    <li>
        <p>The formula may contain an unknown variable (a variable that is not given). However, it is possible to find another
            formula that could be used to find those variables.</p>
    </li>
    <li>
        <p>One physical formula can be used to find several variables. Consider the second Newton’s
                        law:
            <span class="math inline">
                <em>F</em>
                =
                <em>m</em>
                <em>a</em>
            </span>. This formula can be used not only to find a force but also a mass (if the force and the acceleration are known)
            or an acceleration (if the force and the mass are known).</p>
    </li>
</ul>
<p>These discussions guided us to make this recursive algorithm:</p>
<ol>
    <li>
        <p>Find an applicable formula for the unknown variable.</p>
    </li>
    <li>
        <p>Create a set difference of given variables and the free symbols in the found formula. This set will resemble the set
            of unknowns of a formula.</p>
    </li>
    <li>
        <p>If the set is empty, return a list of one element containing the found formula (base
                        case).</p>
    </li>
    <li>
        <p>Otherwise, perform these steps:</p>
        <ol>
            <li>
                <p>For each element in the set, apply this algorithm (recursive
                                        step).</p>
            </li>
            <li>
                <p>Combine all the results. The final result is a list.</p>
            </li>
            <li>
                <p>Append the found formula to the list.</p>
            </li>
            <li>
                <p>Return the list.</p>
            </li>
        </ol>
    </li>
</ol>
<p>We described this algorithm informally because the algorithm can fail in several steps. If the algorithm fails on
    step 1 or step 4.1, this may mean two things: the program cannot find the solution for the unknown variable in the
    problem representation, or the program should find another formula to apply.</p>
<p>Also, we used the term “applicable formula”. This means the formula belongs to the internal list of formulas or is
    derived.</p>
<p>We have quickly noticed that this algorithm is a simplified version of the Stanford Research Institute Problem Solver
    algorithm
    <span class="citation" data-cites="strips">(Fikes and Nilsson 1971)</span>. So, we modified it to the physical field.
        The goals are represented as math symbols. The operators are the applicable formulas. The preconditions of an operator
        (or a formula) are the free symbols of the formula. The initial step is represented as a set of given.</p>
<p>We define the solution to a value change problem as an ordered pair of a floating-point number and a formula. The
    number is the result of dividing the value of a changed value and the original value, and the formula is used to present
    the output for the user.</p>
<p>We invented this problem-solving algorithm for this problem type:</p>
<ol>
    <li>
        <p>Find a formula for which the given variables are a subset of the formula’s
                        variables.</p>
    </li>
    <li>
        <p>Substitute each formula variable with the given variables as a “factor *
                        variable”.</p>
    </li>
    <li>
        <p>Divide the derived formula with the original formula.</p>
    </li>
    <li>
        <p>If the result is a number, then it is the answer to the
                                                            problem.</p>
    </li>
    <li>
        <p>Otherwise, repeat from step #1 and find another formula.</p>
    </li>
</ol>
<p>The algorithm may fail at step 1 or 5, meaning the program could not find the formula to calculate the change. The
    algorithm is simple, and it resembles human thinking.</p>
<h2 id="context" class="subsection">Context</h2>
<p>The first time we made a prototype of the program, we noticed it was
                    limited. Consider a problem: “<em>What is the optical power of a
                    converging lens with a focal length of 40 centimeters?</em>”. A special
                    formula solves this problem (<span class="math inline">$D = \pm
                    \frac{1}{F}$</span>
    ). However, the formula varies whether the lens is a converging lens or a diverging lens. Another situation when we find
    this peculiarity is when we need to calculate the surface of an object (squares, rectangles, triangles, etc.).</p>
<p>We introduce the term context to encode the information about a physical object. Context is a set of strings that
    encode objects and their qualities. Examples of context words: “<em>lens</em>”,
                    “<em>converging</em>”, “<em>diverging</em>”, “<em>square</em>”,
                    “<em>cube</em>”, “<em>rectangle</em>”, etc. In each physics problem,
                    there is an associated context.</p>
<h1 id="results" class="section">RESULTS</h1>
<h2 id="examples-of-program-usage" class="subsection">Examples of program usage</h2>
<p>We will present the solution of 4 problems with different types and comment on how the program solved
        them.</p>
<p>Problem #1: “<em>The car is traveling at a speed of 108 kilometers
                    per hour. Represent this speed in meters per second</em>”.</p>
<figure>
    <img src="/media/image5.png"/>
    <figcaption>The program results for problem #1.</figcaption>
</figure>
<p>Problem #1 is a conversion problem. We haven’t found many problems of this type. The program correctly recognized the
    given quantity and target unit. There is no detailed explanation of the solution because conversion is a primitive
    operation in SymPy.</p>
<p>Problem #2: “<em>Which speed is slower: 72 kilometers per hour or 24
                    meters per second?</em>”.</p>
<figure>
    <img src="/media/image6.png"/>
    <figcaption>The program results for problem #2.</figcaption>
</figure>
<p>Problem #2 is a comparison problem. It is not trivial to compare
    <span class="math inline">$72\frac{km}{h}$</span>
    and
    <span class="math inline">$24\frac{m}{s}$</span>. The program correctly recognized two quantities and the type of the
        problem. According to our problem-solving strategy, the program converted the second value to the unit of the first
        value. Also, our program generates answers based on the word that was asked. For example, if the question asks for
        greater value, the answer will show greater value, and in this example, the program tells us about slower value.</p>
<p>Problem #3: “<em>To raise a marble column weighing 3.78 tons from the bottom of a lake, 95200 joules of work was
    done. Determine the depth of the lake</em>”.</p>
<figure>
    <img src="/media/image7.png"/>
    <figcaption>The program result for problem #3.</figcaption>
</figure>
<p>Problem #3 is an unknown finding problem. We chose this problem because it is not so trivial to solve; it includes
    several formulas for the solution. Unfortunately, this example shows some peculiarities of SymPy and our implementation,
    which we will discuss in the following subsection.</p>
<p>The program correctly recognized the given variables and the unknown variable. The program correctly found the
    solution, including the gravitational force and work formulas. Additionally, the program derived the height from the
    work formula.</p>
<p>Problem #4: “<em>How many times will the moment of a force change if the force is increased by a factor of 8 and the
    arm of the force is decreased by a factor of 4?</em>”.</p>
<figure>
    <img src="/media/image8.png"/>
    <figcaption>The program results for problem #4.</figcaption>
</figure>
<p>Problem #4 is a value change problem. A parser is needed to convert the list of entities to the problem
    representation fully. The program correctly recognized the given changes and the value under question. The program found
    the required formula and performed a substitution, which resulted in a number.</p>
<p>Special attention is required to the term entities. We included the
                    preposition “<em>of</em>” in the
    term. Usually, while recognizing noun phrases (NP), different NPs stay away, but we combined them and determined the
    variable based on the first words. If we did not make this decision, an ambiguity would arise: do we need to find the
    change of the moment or the force?</p>
<h2 id="analysis-of-limitations-of-the-program" class="subsection">Analysis of limitations of the program</h2>
<p>We performed a thorough analysis of issues that our program has. We grouped the issues into several
    categories:</p>
<ol>
    <li>
        <p>Complex problem types.</p>
    </li>
    <li>
        <p>Imperfect natural language processing.</p>
    </li>
    <li>
        <p>Inaccurate problem type recognition.</p>
    </li>
    <li>
        <p>Incomplete problem representation.</p>
    </li>
    <li>
        <p>Imperfect problem-solving techniques.</p>
    </li>
    <li>
        <p>Symbol is semantically equal to terms and objects.</p>
    </li>
    <li>
        <p>Issues with libraries that we use.</p>
    </li>
</ol>
<p>We want to begin the analysis of the limitations of our program by analyzing our problem-type classification. We have
    found that our types can have new subtypes. Consider the problem: “<em>Can
        a wedding ring with a volume of 0.5 cubic centimeters and a mass of 8 grams really be gold?</em>
    ”. It is a new question type for which the answer is a Boolean value. But it is easy to notice that this is a subtype of
    unknown finding problem. The program must compare the object’s density to the actual gold density.</p>
<p>There are lots of issues with natural language processing. We have found that the solution to the problem depends
    highly on the problem formulation. A possible reason is that we used a rule-based approach for NER. Rule-based
    techniques are usually used on the first iteration of NLP program development, and then they are replaced by more
    powerful statistical or neural models
    <span class="citation" data-cites="nlp">(B. et al. 2020)</span>.</p>
<p>Pattern matching, used for NER, restricts the input text to a specific syntax. For example, we require that the units
    are written as proper English words instead of their abbreviations. The program cannot recognize numbers that are not
    written with decimal notation (e.g., “<em>one second</em>”). The patterns require that every quantity has a
                    corresponding unit (the program cannot parse “<em>1 and 4
                    kilograms</em>” as two quantities). Change of a value should be written
                    as “<em>increased by 9</em>” or “<em>reduced by a factor of 2</em>” (but
                    the program cannot parse “<em>the value is halved</em>” or
                    “<em>doubled</em>
    ”). There are many ways to formulate the problem, so there could be lots of patterns in the text that the programmer may
    miss.</p>
<p>Another interesting problem that our application has is that it cannot support tasks with named constants. The
    program cannot infer that the “<em>length of the equator</em>” is about
    <span class="math inline">4 ⋅ 10<sup>4</sup>
        <em>k</em>
        <em>m</em>
    </span>. Also
                    consider the problem: “<em>Find the volume of mercury weighing 2
                                        kilograms</em>
    ”. The program needs to refer to the table of densities and update the problem representation. Our implementation does
    not do it.</p>
<p>The most interesting issue with parsing English text is that it is easy to deceive the program. Consider the problem:
    “<em>The airplane
                    flew 1200 kilometers in 2 hours. At what speed did the airplane
                    fly?</em>”. The program can handle it. But if the user adds this
                    sentence to the end of the text: “<em>Represent the result in meters per
                    second</em>
    ”, then our implementation will think that this problem is a value conversion problem. So, looking at keywords is not
    the best approach to determine the type of problem.</p>
<p>Our problem representation is too basic. The physics problem is not a set of given variables and unknowns. An image
    or a diagram may be included, but the program cannot analyze them. An equation may be offered.</p>
<p>However, one of the biggest issues with problem representation is that we do not support several objects in the task.
    The program cannot recognize the two velocities of two bodies or two capacitors capacitance values in an electric chain.
    The problem lies in the representation of variables; we use only one symbol for them, but an index could also be used in
    the real world.</p>
<p>The solution to some problem types may be more complicated than we provide. This can be illustrated by this problem:
    “<em>
        The masses of two steel balls are 1 kilogram and 4 kilograms. Which of the balls has the greater volume? By how many
        times?</em>
    ”. Again, it is a simple problem for a human to solve, but not the computer. Our program would think this is a
    comparison problem and happily answer that 4 kilograms is bigger than 1. The program should use a formula for inferring
    the volume of objects, but our implementation handles only the given quantities.</p>
<p>Our problem-solving strategy for value change problems is imperfect. We defined that the answer to a value change
    problem results from division. But we can compare values not only with division but also with subtraction. Also, we
    implicitly assume that the physical formulas are created with multiplication and division of variables so that the
    variables will be reduced in the division step. But if the formula is formed with addition, then this strategy will not
    work.</p>
<p>Consider the problem: “<em>How would the mass of an iron ball change
                    if its radius is increased by a factor of two?</em>
    ”. This problem requires two formulas to find (one for the volume and one that involves the density of iron). It is easy
    to notice that we can reuse the STRIPS algorithm to find the unknowns of the first formula, but there lies a new degree
    of complexity.</p>
<p>We propose a hypothesis that it is impossible to construct an efficient algorithm for solving value change problems.
    For every unknown variable in the formula, the program should decide whether to leave it as is (hoping it will be
    reduced in the division) or to find another formula. But that second formula could also have unknown variables.
    Moreover, it may miss some changes if the program doesn’t use a formula for some unknowns.</p>
<p>There is a theoretical issue with our program. Our problem-solving algorithm treats physical terms and objects as
    variables. But, in the real world, variables resemble physical terms. With this issue, an ambiguity arises:
    <span class="math inline">
        <em>c</em>
    </span>
    may mean either capacitance or speed of light, but the program considers these terms equal because they are written with
    the same symbol.</p>
<p>We have used a special technique for treating a QUANTITY entity as a given value if there is no TERM entity. If the
    program encounters a “<em>2 meters</em>”” entity, it will treat it as
    <span class="math inline">
        <em>S</em>
        = 2
        <em>m</em>
    </span>. We have found that this is another ambiguity in our implementation. This entity can be not
        only
    <span class="math inline">
        <em>S</em>
    </span>, but also
    <span class="math inline">
        <em>l</em>
    </span>,
    <span class="math inline">
        <em>h</em>
    </span>,
    <span class="math inline">
        <em>d</em>
    </span>, etc.</p>
<p>There are also various issues with the libraries we use. The SymPy treats the unit of a physical value as a variable,
    so problems with printing may arise. Another problem is that SymPy does not know that Joule divided by Newton is a
    meter. Not enough units are provided in the SymPy library. The library documentation is too short, and we have not found
    a simple way to resolve these issues.</p>
<h1 id="conclusions" class="section">CONCLUSIONS</h1>
<p>In this paper, we have studied the automatic solving of physics word problems. PWP solving is a challenging subfield
    of word problem solving that requires complex problem representation. We have found that researched solutions for math
    word problems are unsuitable for solving PWP. Current PWP solvers are focused on specific problem types, while we were
    interested in generic PWP solvers.</p>
<p>To study our papers object and subject, we developed and described a program that could solve simple physics
    problems. Our testing dataset was formed from Ukrainian physics textbooks. The development of word problem solvers
    focuses mainly on problem representation, natural language processing, and problem-solving strategies.</p>
<p>Our analysis shows that PWPs fall into five categories: theoretical, value conversion, value comparison, unknowns
    finding, and value change problems.</p>
<p>To convert problem text into the internal problem representation, we chose named entity recognition based on pattern
    matching. Other techniques for NER besides pattern matching on tokens can be used to analyze problem text, such as
    pattern matching on trees and statistical and neural models. Problem types are recognized based on the presence of
    particular entities. While this approach was sufficient on our small dataset, we have noticed that this solution could
    be easily broken. After NER, another step is required to convert a list of entities into the representation.</p>
<p>We have found a new kind of ambiguity: “quantity without a term”. This type of ambiguity occurs when the program
    finds a quantity entity that is a given value, but the program cannot infer the variable for this quantity. We partially
    solved this problem by inferring the variable by the unit of the quantity.</p>
<p>Our research shows that the algorithm for solving problems with unknown values is the STRIPS algorithm. Value change
    problems are complex problems to solve because of many non-trivial parameters. We hypothesize that these problems cannot
    be solved efficiently and belong to the class of “NP-hard” problems.</p>
<p>While our program can solve static computational physics problems, it is obvious that there are many other types of
    physics problems. Our program can be improved by choosing different NLP methods and by developing a more sophisticated
    problem representation.</p>
<h1 class="unnumbered" id="references" class="section">REFERENCES</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
    <div id="ref-nlp" class="csl-entry" role="listitem">
        B., S. V., B. Majumder, A. Gupta, and H. Surana. 2020.
        <em>Practical Natural Language Processing: A Comprehensive Guide to Building Real-World NLP
                        Systems</em>. O’Reilly Media.
    </div>
    <div id="ref-student" class="csl-entry" role="listitem">
        Bobrow, D. 1964.
        <span>“Natural Language Input for a Computer Problem
                                                            Solving System.”</span>
        In
        <em>Semantic Information Processing</em>,
                                                            146–226. Cambridge, MA: USA:MIT Press.
    </div>
    <div id="ref-mecho" class="csl-entry" role="listitem">
        Bundy, A., L. Byrd, G. Luger, C. Mellish, R. Milne, and M. Palmer. 1979.
        <span>“MECHO: A Program to Solve Mechanics Problems.”</span>
        <em>Department of Artificial Intelligence, University of Edinburgh</em>.
                                                            https://doi.org/<a href="http://www.worldcat.org/title/mecho-a-program-to-solve-mechanics-problems/oclc/475999217.">
            http://www.worldcat.org/title/mecho-a-program-to-solve-mechanics-problems/oclc/475999217.</a>
    </div>
    <div id="ref-strips" class="csl-entry" role="listitem">
        Fikes, R. E., and N. J. Nilsson. 1971.
        <span>“Strips: A New Approach to the Application of Theorem Proving to Problem
            Solving.”</span>
        <em>Artificial Intelligence</em>
        2 (3): 189–208.
        <a href="https://doi.org/10.1016/0004-3702(71)90010-5">https://doi.org/10.1016/0004-3702(71)90010-5</a>.
    </div>
    <div id="ref-frust_soc" class="csl-entry" role="listitem">
        Gregorcic, B., and A.-M. Pendrill. 2023.
        <span>“ChatGPT and the
                                                            Frustrated Socrates.”</span>
        <em>Physics Education</em>
        58 (3): 035021.
        <a href="https://doi.org/10.1088/1361-6552/acc299">https://doi.org/10.1088/1361-6552/acc299</a>.
    </div>
    <div id="ref-newton" class="csl-entry" role="listitem">
        Kleer, J. 1977.
        <span>“Multiples Representations of Knowledge in a Mechanics
            Problem-Solver.”</span>
        In
        <em>Proceedings of the 5th International Joint Conference on Artificial
            Intelligence</em>, 1:299–304. USA. San
            Francisco, CA, USA: Morgan Kaufmann Publishers Inc.
        <a href="https://doi.org/10.1016/B978-1-4832-1447-4.50009-2">https://doi.org/10.1016/B978-1-4832-1447-4.50009-2</a>.
    </div>
    <div id="ref-modern_pwp" class="csl-entry" role="listitem">
        Leszczynski, Megan, and José E. Moreira. 2017.
        <span>“Machine Solver for
                                                            Physics Word Problems.”</span>
        In.
        <a href="https://api.semanticscholar.org/CorpusID:58605280">https://api.semanticscholar.org/CorpusID:58605280</a>.
    </div>
    <div id="ref-mwp_repr" class="csl-entry" role="listitem">
        Mandal, S., and S. K. Naskar. 2019.
        <span>“Solving Arithmetic Mathematical Word Problems: A Review and Recent
            Advancements.”</span>
        Edited by P. Chandra, D. Giri, F. Li, S. Kar, and D. K. Jana.
        <em>Information Technology and Applied Mathematics</em>, 95–114.
        <a href="https://doi.org/10.1007/978-981-10-7590-2_7">https://doi.org/10.1007/978-981-10-7590-2_7</a>.
    </div>
    <div id="ref-other_pwp" class="csl-entry" role="listitem">
        Mukherjee, A., and U. Garain. 2008.
        <span>“A Review of Methods for Automatic Understanding of Natural Language Mathematical
                                    Problems.”</span>
        <em>Artificial Intelligence Review</em>
        29 (2):
                                        93–122.
        <a href="https://doi.org/10.1007/s10462-009-9110-0">https://doi.org/10.1007/s10462-009-9110-0</a>.
    </div>
    <div id="ref-paip" class="csl-entry" role="listitem">
        Norvig. 1991.
        <em>Paradigms of Artificial Intelligence Programming: Case Studies in Common
            Lisp</em>. 1st ed. Morgan Kaufmann.
        <a href="https://unglueit-files.s3.amazonaws.com/ebf/59f74a93bbc1435c9ca1557b4bb6e9ba.pdf">
            https://unglueit-files.s3.amazonaws.com/ebf/59f74a93bbc1435c9ca1557b4bb6e9ba.pdf</a>.
    </div>
    <div id="ref-isaac" class="csl-entry" role="listitem">
        Novak, G. S., Jr. 1976.
        <span>“Computer Understanding of Physics Problems Stated in Natural
            Language.”</span>
        <em>American Journal of
                                                            Computational Linguistics</em>.
        <a href="https://aclanthology.org/J76-3005.">https://aclanthology.org/J76-3005.</a>
    </div>
    <div id="ref-aima" class="csl-entry" role="listitem">
        Russell, S., and P. Norvig. 2009.
        <em>Artificial Intelligence: A Modern
                                                            Approach</em>. 3rd ed. USA: Prentice Hall Press.
        <a href="https://people.engr.tamu.edu/guni/csce421/files/AI_Russell_Norvig.pdf">
            https://people.engr.tamu.edu/guni/csce421/files/AI_Russell_Norvig.pdf</a>.
    </div>
    <div id="ref-mwp_nlp" class="csl-entry" role="listitem">
        Zhang, Dongxiang, Lei Wang, Luming Zhang, Bing Tian Dai, and Heng Tao Shen. 2020.
        <span>“The Gap of Semantic Parsing: A Survey on Automatic Math Word Problem
            Solvers.”</span>
        <em>IEEE Transactions on Pattern
                                                            Analysis and Machine Intelligence</em>
        42 (9): 2287–2305.
        <a href="https://doi.org/10.1109/TPAMI.2019.2914054">https://doi.org/10.1109/TPAMI.2019.2914054</a>.
    </div>
    <div id="ref-ukr_ph_1" class="csl-entry" role="listitem">
        Гельфгат, І. 2009.
        <em>Фізика. 7 Клас: Збірник Задач</em>. 4th ed.
                                                            Веста.
    </div>
    <div id="ref-ukr_ph_2" class="csl-entry" role="listitem">
        Ненашев, І. 2011.
        <em>Фізика. 8 Клас: Збірник Задач</em>. 5th ed. Веста.
    </div>
</div>